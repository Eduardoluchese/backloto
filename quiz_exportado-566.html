
    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Quiz Exportado</title>
      <style>
      body {
           font-family: 'Poppins', sans-serif;      
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: flex-start;
                min-height: 100vh; /* Garante altura mínima de 100% */
            }
            #quiz-container {
                width: 100%; /* Ocupa toda largura */
                min-height: 100vh; /* Altura mínima de 100% da viewport */
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .quiz-section {
                display: none;
                width: 100%;
                min-height: 100vh; /* Altura mínima de 100% */
                padding: 20px 0;
                box-sizing: border-box;
            }
            .quiz-section.active {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .content {
                width: 100%;
                max-width: 600px;
                margin: 0 auto;
                padding: 0 20px;
                box-sizing: border-box;
            }
        /* Estilos para os botões exportados */
    .mobile-button {
  position: relative;
  width: 100%;
  min-height: 65px;
  display: flex;
  align-items: center;
  border-radius: 0.75rem;
  border: 1px solid;
  font-size: 20px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: background 0.3s;
}


/* Efeito de hover para mobile-button */
.mobile-button:hover {
  background: linear-gradient(45deg, var(--hover-color), var(--hover-color)) !important;
}
        .mobile-button .emoji {
          margin-left: -10px;
          font-size: 40px;
          margin-right: 20px;
          flex-shrink: 0;
        }
        .mobile-button .text {
          flex: 1;
          text-align: left; /* Alinhamento padrão */
        }
        /* Efeito de hover para mobile-button */

     
        /* Estilos para links personalizados */
        .mobile-button a {
          text-decoration: none;
          color: inherit;
          display: flex;
          align-items: center;
          width: 100%;
          height: 100%;
        }
        /* Estilos adicionais existentes */
        button {
          padding: 8px 16px;
          border: none;
          border-radius: 5px;
          background-color: #89b4fa;
          color: #1e1e2e;
          cursor: pointer;
          transition: background-color 0.3s;
        }
        button:hover {
          background-color: #b4befe;
        }
        .mobile-progress {
          width: 100%;
          margin: 15px 0;
          position: relative;
        }
        .progress-bar {
          width: 100%;
          height: 20px;
          background-color: #313244;
          border-radius: 10px;
          overflow: hidden;
        }
        .progress-fill {
          height: 100%;
          background-color: #89b4fa;
          transition: width 0.3s ease-out;
          width: 0;
        }
        .progress-value {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          color: #ffffff;
          font-size: 12px;
          font-weight: bold;
          text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        .mobile-feedback {
          width: 100%;
          margin-bottom: 10px;
          border-radius: 10px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .feedback-container {
          padding: 15px;
          display: flex;
          align-items: flex-start;
          margin-bottom: 30px;
        }
        .feedback-image {
          width: 50px;
          height: 50px;
          border-radius: 50%;
          margin-right: 15px;
        }
        .feedback-content {
          flex: 1;
        }
        .feedback-name {
          font-weight: bold;
          margin-bottom: 2px;
        }
        .feedback-location {
          font-size: 0.9em;
          margin-bottom: 5px;
        }
        .feedback-stars {
          color: #FFD700;
          margin-bottom: 5px;
        }
        .feedback-text {
          font-style: italic;
          line-height: 1.4;
        }
/* Estilos do Widget de Celular */
.mobile-phone-widget {
          width: 100%;
          max-width: 600px;
          margin: 0 auto 10px auto;
        }
        .mobile-phone-widget .elements {
          background-color: #f9fafb;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
          position: relative;
          height: 250px;
          display: flex;
          align-items: center;
          border-radius: 40px 20px 20px 40px;
          width: 100%;
          max-width: 600px;
          margin: 0 auto 30px auto;
          border: 1px solid #e5e7eb;

        }
        .mobile-phone-widget .phone-frame {
          position: absolute;
          left: 0;
          width: 120px;
          height: 96%;
          border: 6px solid black;
          border-radius: 1.5rem;
          overflow: hidden;
          margin-left:-1px;
        }
        .mobile-phone-widget .phone-frame img {
          width: 100%;
          height: 100%;
          object-fit: cover;
        }
        .mobile-phone-widget .iphone-detalhe {
          position: absolute;
          height: 10px;
          background-color: black;
          width: 60px;
          margin: 0 auto;
          border-radius: 0px 0px 40px 40px;
          left: 50%;
          transform: translateX(-50%);
          top: 0;
        }

        .mobile-phone-widget .text {
          margin-left: 140px;
          padding-right: 10px;
        }
        .mobile-phone-widget .text h2 {
          margin-top: 0;
        }
   
        .mobile-phone-widget[data-position="right"] .elements {
          border-radius: 20px 40px 40px 20px;
        }
        .mobile-phone-widget[data-position="right"] .phone-frame {
          left: auto;
          right: 0;
          margin-right: -1px;
        }
        .mobile-phone-widget[data-position="right"] .text {
          margin-left: 20px;
          margin-right: 140px;
          padding-right: 0;
        }
        .mobile-phone-widget .phone-content {
          padding: 0px;
          box-sizing: border-box;
          height: 100%;
          width: 100%;
          object-fit: cover;
        }
        .mobile-text {
          width: 100%;
          max-width: 600px;
          margin: 0 auto 10px auto;
        }

        .mobile-image {
    width: 100%;
    display: block;
    margin-bottom: 10px;
}

.mobile-image img {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 1rem;
    object-fit: contain;
}
   
          /* Estilos da Nota */
.mobile-note {
  width: 100%;
  margin-bottom: 10px;
}

.notes {
  font-family: "Poppins", sans-serif;
  border-radius: 0.75rem;
  position: relative;
  background-color: #f9fafb;
  display: flex;
  padding: 15px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  border: 1px solid #e5e7eb;
}

.texts-notes {
  padding-left: 42px;
  flex: 1;
}

.icon {
  flex-shrink: 0;
}

.icon svg {
  width: 32px;
  height: 32px;
  fill: #f59e0b;
}

.title-notes {
  font-size: 1.25rem;
  font-weight: 700;
  padding-bottom: 10px;
}
.icon {
  position: absolute;
  top: 0;
  left: 0;
  margin: 10px 0px 0px 10px;
}
  /* Estilos para o Multiple Choice exportado */
.mobile-multiple-choice {
 width: 100%;
 margin-bottom: 20px;
}

.options-grid {
 display: flex;
 flex-direction: column;
 gap: 10px;
}

.option-button {
 position: relative;
 width: 100%;
 min-height: 65px;
 display: flex;
 align-items: center;
 justify-content: space-between;
 border-radius: 0.75rem;
 border: 1px solid rgb(214, 214, 214);
 background: linear-gradient(45deg, rgb(244, 244, 244), rgb(255, 255, 255));
 font-size: 20px;
 margin-bottom: 10px;
 cursor: pointer;
 padding: 0;
 transition: all 0.3s;
}

.option-content {
 display: flex;
 align-items: center;
 width: 100%;
 padding: 15px 20px;
}

.emoji {
 font-size: 40px;
 margin-right: 20px;
 margin-left: -10px;
 flex-shrink: 0;
}

.option-text {
 text-align: left;
 font-size: 1rem;
 flex: 1;
 line-height: 1.3;
}

.checkbox {
 width: 24px;
 height: 24px;
 border: 2px solid #d6d6d6;
 border-radius: 4px;
 background: white;
 position: relative;
 flex-shrink: 0;
}

.option-button.active .checkbox {
 background: #9333ea;
 border-color: #9333ea;
}

.option-button.active .checkbox::after {
 content: "";
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%) scale(1);
 width: 16px;
 height: 16px;
 background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 448 512'%3E%3Cpath fill='white' d='M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z'/%3E%3C/svg%3E");
 background-repeat: no-repeat;
 background-position: center;
}

.continue-button {
 width: 100%;
 min-height: 65px;
 border-radius: 0.75rem;
 border: none;
 background: #9333ea;
 color: white;
 font-size: 20px;
 margin-top: 20px;
 cursor: not-allowed;
 opacity: 0.5;
 transition: all 0.3s;
}

.continue-button.active {
 opacity: 1;
 cursor: pointer;
}

.continue-button:hover {
 opacity: 0.9;
}

.input-container {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  position: relative;
  box-sizing: border-box;
}
.input-widget input.input-field {
  width: 100%;
  padding: 24px 60px;
  border: 1px solid rgb(229, 231, 235);
  border-radius: 0.75rem;
  font-size: 17px;
  background-color: rgb(249, 250, 251);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 2px 8px rgba(0, 0, 0, 0.02);
  transition: all 0.3s;
  box-sizing: border-box;
  color: black;
  margin: 0 !important;
}
.input-field::placeholder {
  font-size: 17px;
}
.input-field:focus {
  outline: none;
  box-shadow: inset 0 0 0 2px currentColor;
}

.user-icon {
  position: absolute;
  left: 14px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  justify-content: center;
  width: 30px;
  height: 40px;
  pointer-events: none;
}



.user-icon svg {
  height: 40px;
  fill: currentColor;
  stroke: none;
}

.user-icon svg path {
  fill: currentColor;
  stroke: none;
  stroke-width: 0;
}
.input-widget input.input-field::placeholder {
  color: var(--placeholder-color, currentColor);
  opacity: 0.5;
  font-size: 17px;
}
  /* Estilos do Video Player */
  /* Atualização dos estilos do vídeo */
      .mobile-video .container {
        container-type: inline-size;
        max-width: 600px;
        margin: 0 auto;
      }

      .mobile-video .video-container {
        position: relative;
        width: 100%;
        height: 0;
        padding-bottom: 133.33%;
        background-color: transparent;
        overflow: hidden;
        border-radius: 1rem;
      }

      .video-iframe {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 101%; /* Aumentado levemente para cobrir possíveis gaps */
        height: 101%; /* Aumentado levemente para cobrir possíveis gaps */
        transform: translate(-50%, -50%);
        border: none;
        background: #000; /* Fundo preto para espaços vazios */
      }

      .mobile-video .blur-background {
        position: absolute;
        top: -1px; /* Ajuste para eliminar gaps */
        left: -1px; /* Ajuste para eliminar gaps */
        width: calc(100% + 2px); /* Compensação para os gaps */
        height: calc(100% + 2px); /* Compensação para os gaps */
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        z-index: 199;
        display: block;
      }

      .mobile-video .overlay {
        color: #fff;
        position: absolute;
        padding: 2cqw;
        width: 50%;
        height: 40%;
        background-color: #5d3f92;
        z-index: 200;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 2cqw;
        text-align: center;
        border-radius: 8px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
      }

    .mobile-video .overlay-title {
      font-family: Arial, sans-serif;
      font-size: 5cqw;
      font-weight: bold;
      margin: 0;
      text-transform: uppercase;
    }

    .mobile-video .overlay-text {
      font-family: Arial, sans-serif;
      font-size: 5cqw;
      margin: 0;
    }

    .mobile-video .play-icon {
      position: relative;
      height: 50%;
    }

    .mobile-video .top-overlay,
    .mobile-video .bottom-overlay {
      position: absolute;
      left: 0;
      width: 100%;
      background-color: transparent;
      z-index: 300;
      pointer-events: auto;
    }

    .mobile-video .top-overlay {
      top: 0;
      height: 20%;
    }

    .mobile-video .bottom-overlay {
      bottom: 0;
      height: 20%;
    }

    .mobile-video .hidden {
      display: none;
    }

    .mobile-video .play-icon path,
    .mobile-video .play-icon circle {
      transition: all 0.3s ease;
    }
          /* Estilos da Galeria */


.mobile-gallery {
  width: 100%;
  max-width: 600px;
  margin: 0 auto 20px;
}

.gallery-container {
  border-radius: 0.75rem;
  overflow: hidden;
  position: relative;
}

.gallery-track {
  display: flex;
  transition: transform 0.3s ease;
  width: 100%;
}

.gallery-slide {
  flex: 0 0 100%;
  width: 100%;
}

.gallery-slide img {
  width: 100%;
  height: auto;
  display: block;
}

.gallery-nav {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-top: 12px;
}

.gallery-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.25s ease;
  opacity: 1;
}

.gallery-dot.active {
  transform: scale(1.2);
}
/* Estilos do FAQ */
.mobile-faq {
  width: 100%;
  margin-bottom: 20px;
}

.faq-item {
  border: 1px solid #e5e7eb;
  border-radius: 0.75rem;
  margin-bottom: 10px;
  background-color: #fff;
  overflow: hidden;
}

.faq-header {
  width: 100%;
  display: flex;
  align-items: center;
  padding: 15px;
  background: none;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s;
  position: relative; /* Adicionado */
}

.faq-header:hover {
  background-color: #f8fafc;
}

.faq-icon {
  position: relative; /* Adicionado */
  margin-right: 15px;
  width: 24px;
  height: 24px;
  transition: transform 0.3s;
  flex-shrink: 0;
  overflow: hidden; /* Adicionado */
}

.faq-icon svg {
  width: 100%;
  height: 100%;
}

.faq-header.active .faq-icon {
  transform: rotate(45deg);
}

.faq-title {
  font-weight: 600;
  font-size: 1.1rem;
  color: #000;
  text-align: left;
}

.faq-content {
  max-height: 0;
  overflow: hidden;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  padding: 0 15px;
  opacity: 0;
}

.faq-content.active {
  max-height: max-content;
  padding: 15px;
  opacity: 1;
  border-top: 1px solid #e5e7eb;
  background-color: #f8fafc;
}

.faq-answer {
  color: #4b5563;
  line-height: 1.6;
}
.faq-icon svg {
  width: 24px;
  height: 24px;
  position: absolute; /* Adicionado */
  top: 0;
  left: 0;
}
/* Container principal do Score */
.mobile-score {
  display: flex;
  max-width: 600px;
}
.mobile-score .score-container {
  /* Mantém layout fixo até certo ponto, mas permite encolher */
  width: clamp(300px, 90vw, 600px); 
  /* ou max-width: 600px e width: 100%, mas clamp() dá mais controle */

  margin: 20px auto;
  padding: 20px;

  background: #f8f9fe;
  border-radius: 16px;
  font-family: Arial, sans-serif;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  border: 1px solid #e5e7eb;

  display: flex;
  justify-content: space-around;
  /* se quiser garantir que NUNCA quebre as colunas, use flex-wrap: nowrap */
  flex-wrap: nowrap; 
}

.mobile-score .score-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  /* Se deseja manter 2 colunas sempre, dá pra fixar width. 
     Mas se quiser levemente flexível, pode usar clamp também */
  width: 45%; 
}

.mobile-score .score-title {
  text-align: center;
  /* fonte responsiva: encolhe mas não fica minúscula */
  font-size: clamp(18px, 4vw, 24px); 
  font-weight: bold;
  margin-bottom: 20px;
  min-height: 60px;

  display: flex;
  align-items: center;
  justify-content: center;
}

/* A parte circular */
.mobile-score .circle-wrap {
  /* largura/altura também responsivas */
  width: clamp(140px, 38vw, 205px);
  height: clamp(140px, 38vw, 205px);

  position: relative;
  background: conic-gradient(#a31b1b 0%, #dc2626 85%, rgb(229, 231, 235) 0deg);
  border-radius: 50%;
}

.mobile-score .percent {
  /* fonte responsiva também */
  font-size: clamp(24px, 5vw, 36px);
  font-weight: bold;

  background: #ffffff;
  width: clamp(110px, 32vw, 170px);
  height: clamp(110px, 32vw, 170px);

  border-radius: 50%;
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);

  display: flex;
  align-items: center;
  justify-content: center;
}

.mobile-score .score-avatar {
  /* Responsivo para imagem */
  width: clamp(140px, 38vw, 200px);
  height: clamp(140px, 38vw, 200px);
  border-radius: 8px;
  object-fit: cover;
}




       .mobile-button,
        .mobile-text,
        .mobile-image,
        .mobile-progress,
        .mobile-feedback,
        .mobile-phone-widget,
        .mobile-note,
        .mobile-multiple-choice,
        .input-widget,
        .mobile-video .container,
        .mobile-gallery {
          width: 100%;
          margin:0 auto;
          margin-bottom: 40px; /* Padronizando o espaçamento */
        }
      </style>
    </head>
    <body>
       <div id="quiz-container">
            <section id="section-0" class="quiz-section active" style="background-color: #ffffff">
                <div class="content" style="color: #000000;">
                    <div class="mobile-text" id="text-1738933209755" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(255, 255, 255);"><h1><div style=" background-color:green; padding:10px; border-radius:10px">🎁  PARABÉNS VOCÊ GANHOU 30R$</div></h1></div><div class="mobile-text" id="text-1738933641312" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(68, 68, 68); position: relative;"><h3>🚨 Esta oportunidade  se encerrará se sair dessa página</h3></div><div id="image-1738933728941" class="mobile-image" style="position: relative; max-width: 385px; width: 100%; margin-inline: auto;"><img src="https://i.ibb.co/GfMfwxnv/Design-sem-nome-3.jpg" alt="Imagem" style="width: 100%; height: auto;"></div><div class="mobile-text" id="text-1738933735081" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(46, 7, 62); position: relative;"><h2>🔥 Por tempo limitado estamos liberando<u> 15 vagas </u>extras com <u>R$20,00 de desconto</u></h2></div><div id="image-1738934376943" class="mobile-image" style="position: relative; max-width: 384px; width: 100%; margin-inline: auto;"><img src="https://i.ibb.co/xS6sDd9M/Design-sem-nome-4.jpg" alt="Imagem" style="width: 100%; height: auto;"></div><div class="mobile-text" id="text-1738933815029" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(68, 68, 68); position: relative;"><h3>De <span style="font-size:30px; color:red;"> <s>R$47 ,00</s></span>  por apenas <span style="font-size:50px; color:GREEN;"><br> R$17</span> </h3></div><button class="mobile-button" id="button-1738934162188" style="background: linear-gradient(45deg, rgb(102, 156, 53), rgb(119, 187, 65)); border-color: rgb(56, 87, 26); position: relative; border-bottom-width: 8px; box-shadow: rgba(0, 0, 0, 0.2) 0px 4px 8px -1px, rgba(0, 0, 0, 0.12) 0px 2px 4px -1px; transform: translateY(-2px); opacity: 1;" data-hover-color="#77bb41" data-delay="0" data-link="https://pay.kiwify.com.br/NGv6arP"><span class="emoji">✅</span><span class="text" style="color: rgb(255, 255, 255); text-align: center;">Quero aproveitar R$20 OFF</span></button><div class="mobile-text" id="text-1738934424009" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(68, 68, 68); position: relative;"><p>
🔒 Pagamento seguro
</p></div><div class="mobile-text" id="text-1738934475297" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(68, 68, 68);"><h3>✅ Sistema Comprovado<br>
🏆 Resultados Reais<br>
🤖 Tecnologia Avançada<br>
</h3></div><div class="mobile-text" id="text-1738934552959" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(46, 7, 62);"><h2>O que você prefere?</h2></div><div class="mobile-text" id="text-1738934597559" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(181, 26, 0);"><p>💸 Continuar gastando CENTENAS DE REAIS em apostas aleatórias... </p></div><div class="mobile-text" id="text-1738934617597" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(46, 7, 62);"><h2><div style="margin:-30px;">ou...</div></h2></div><div class="mobile-text" id="text-1738934629772" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(79, 122, 40); position: relative;"><h2>✨ Investir apenas R$ 17,00 AGORA e multiplicar suas chances de acertar 14 pontos!</h2></div><button class="mobile-button" id="button-1738934681472" style="background: linear-gradient(45deg, rgb(102, 156, 53), rgb(119, 187, 65)); border-color: rgb(56, 87, 26); position: relative; border-bottom-width: 8px; box-shadow: rgba(0, 0, 0, 0.2) 0px 4px 8px -1px, rgba(0, 0, 0, 0.12) 0px 2px 4px -1px; transform: translateY(-2px); opacity: 1;" data-hover-color="#77bb41" data-delay="0" data-link="https://pay.kiwify.com.br/NGv6arP"><span class="emoji">✅</span><span class="text" style="color: rgb(255, 255, 255); text-align: center;">Quero aproveitar R$20 OFF</span></button><div class="mobile-text" id="text-1738934814323" style="font-weight: bold; font-style: normal; text-align: center; color: rgb(68, 68, 68); position: relative;"><p>
🔒 Pagamento seguro
</p></div><button class="mobile-button" id="button-1738934737514" style="background: linear-gradient(45deg, rgb(181, 26, 0), rgb(131, 17, 0)); border-color: rgb(92, 7, 0); position: relative; border-bottom-width: 8px; box-shadow: rgba(0, 0, 0, 0.2) 0px 4px 8px -1px, rgba(0, 0, 0, 0.12) 0px 2px 4px -1px; transform: translateY(-2px); opacity: 1;" data-hover-color="#b51a00" data-delay="0" data-link="https://pay.kiwify.com.br/NGv6arP"><span class="emoji"></span><span class="text" style="color: rgb(255, 255, 255); text-align: center;">Deixar vaga para  outra  pesssoa</span></button><div id="note-1738934931464" class="mobile-note" style="position: relative;">
      <div class="notes" style="background-color: rgb(249, 250, 251); border-color: rgb(229, 231, 235);">
        <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z" style="fill: rgb(245, 158, 11);"></path></svg></div>
        <div class="texts-notes">
          <div class="title-notes" style="color: rgb(0, 0, 0);">Garantia</div>
          <div class="texto-notes" style="color: rgb(0, 0, 0);">Não esqueça, você tem  14 dias de garantia para gerar quantos jogos quiser, e se nao ganhar nenhum premio pode pedir todo seu dinheiro de volta</div>
        </div>
      </div>
    </div>
                </div>
            </section>
 </div>
<script>
  // Dados de conexões fornecidos no formato JSON
  const connectionsData = [];

      /*************************************************************
       * 1) CONFIGURAÇÃO DO WEBHOOK E INFORMAÇÕES DO QUIZ
       *************************************************************/
      const ANALYTICS_CONFIG = {
        webhookUrl:
          "https://script.google.com/macros/s/AKfycbzl-OEF6f7yhlSJaLrJYLaa58vXPVLNPe_i3omnAMLzPjLWrYUDJISccDIcR6mplsOVIg/exec", // Substitua pela URL do seu Google Apps Script
        quizId: "quiz_" + Date.now(), // ID único do quiz baseado no timestamp atual
        quizName: "Terrace", // Nome do quiz
        quizCategory: "Teste", // Categoria do quiz
      };

      /*************************************************************
       * 2) OBJETO PRINCIPAL DE ANALYTICS
       *************************************************************/
      const quizAnalytics = {
        // Alguns campos comentados porque não são necessários no momento
        // quizId: ANALYTICS_CONFIG.quizId,
        quizName: ANALYTICS_CONFIG.quizName,
        // quizCategory: ANALYTICS_CONFIG.quizCategory,
        // userId: "user_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9),
        // sessionId: "session_" + Date.now(),
        startTime: Date.now(), // Tempo de início do quiz
        endTime: null, // Tempo de término do quiz
        furthestSection: "section-0", // Seção mais avançada atingida
        responses: {}, // Respostas do usuário
         city: "", // Cidade do usuário
        state: "", // Estado do usuário
        postalCode: "", // Código postal do usuário
        device: "", // Tipo de dispositivo do usuário
        // Campos opcionais para inputs (nome, email, whatsapp)
        nome: "",
        email: "",
        whatsapp: "",
      };

      /*************************************************************
       * 3) FUNÇÃO PARA ENVIAR OS DADOS PARA O WEBHOOK
       *************************************************************/
      async function sendAnalytics() {
        try {
          // Sincronizar userVariables com quizAnalytics
          quizAnalytics.nome = userVariables.nome || "";
          quizAnalytics.email = userVariables.email || "";
          quizAnalytics.whatsapp = userVariables.whatsapp || "";
          quizAnalytics.city = quizAnalytics.city || "Desconhecida"; // Garantir que a cidade esteja definida

          const dataToSend = [quizAnalytics];

          await fetch(ANALYTICS_CONFIG.webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
              data: JSON.stringify(dataToSend),
            }),
          });
          console.log("Analytics enviado com sucesso.");
        } catch (error) {
          console.error("Erro ao enviar analytics:", error);
        }
      }


         /*************************************************************
     FUNÇÃO PARA DETECTAR O TIPO DE DISPOSITIVO
     *************************************************************/
    function detectDeviceType() {
      const ua = navigator.userAgent;
      if (/android/i.test(ua)) {
        return "Android";
      }
      if (/iPhone|iPad|iPod/i.test(ua)) {
        return "iOS";
      }
      if (/Windows Phone/i.test(ua)) {
        return "Windows Phone";
      }
      if (/Macintosh/i.test(ua)) {
        return "Mac";
      }
      if (/Windows/i.test(ua)) {
        return "Windows";
      }
      if (/Linux/i.test(ua)) {
        return "Linux";
      }
      return "Other";
    }

    // Definir o tipo de dispositivo no início
    quizAnalytics.device = detectDeviceType();

        /*************************************************************
        * 4) QUANDO SAIR DA PÁGINA (pagehide, beforeunload e visibilitychange), ENVIA DADOS
        *************************************************************/
        let dataSent = false; // Flag para evitar envios duplicados

        function handlePageHide() {
          if (dataSent) return; // Se os dados já foram enviados, não faz nada
          dataSent = true; // Define a flag como true para prevenir futuros envios

          quizAnalytics.endTime = Date.now(); // Registrar o tempo de término

          // Sincronizar userVariables com quizAnalytics
          quizAnalytics.nome = userVariables.nome || "";
          quizAnalytics.email = userVariables.email || "";
          quizAnalytics.whatsapp = userVariables.whatsapp || "";

          const dataToSend = [quizAnalytics];
          const blob = new Blob(
            [new URLSearchParams({ data: JSON.stringify(dataToSend) })],
            { type: "application/x-www-form-urlencoded" }
          );
          navigator.sendBeacon(ANALYTICS_CONFIG.webhookUrl, blob); // Enviar dados usando sendBeacon
        }

        function handleVisibilityChange() {
          if (document.visibilityState === 'hidden') {
            handlePageHide();
          }
        }

        // Adicionar listeners para pagehide, beforeunload e visibilitychange
        window.addEventListener("pagehide", handlePageHide);
        window.addEventListener("beforeunload", handlePageHide);
        document.addEventListener("visibilitychange", handleVisibilityChange);

          /*************************************************************
         * 5) EVENTO DE CLIQUE PARA GRAVAR RESPOSTAS E NAVEGAR ENTRE SEÇÕES
         *************************************************************/
document.addEventListener("click", function (e) {
  const button = e.target.closest(".mobile-button"); // Identificar o botão clicado
  if (button) {
    // Verificar se o botão está desabilitado
    if (button.disabled || button.style.pointerEvents === "none") {
      return; // Ignorar cliques em botões desabilitados ou não interativos
    }

    const link = button.getAttribute("data-link");
    if (link) {
      // Enviar analytics antes de redirecionar
      quizAnalytics.endTime = Date.now(); // Registrar o tempo de término
      sendAnalyticsAndRedirect(link);
      return; // Evitar chamar showSection
    }

    const buttonId = button.id;
    const connection = connectionsData.find(
      (conn) => conn.elementId === buttonId
    );
    if (connection) {
      // Registrar a resposta correspondente à seção
      const sectionId = connection.startIndex;
      const resposta = button.querySelector(".text").textContent;
      quizAnalytics.responses["section_" + sectionId] = resposta;

      showSection("section-" + connection.endIndex); // Mostrar a próxima seção
    }
  }
});

/*************************************************************
 *  função que envia os dados de analytics antes de redirecionar
 *************************************************************/
function sendAnalyticsAndRedirect(url) {
  if (dataSent) return; // Evita envios duplicados
  dataSent = true; // Marca que os dados estão sendo enviados

  // Sincronizar userVariables com quizAnalytics
  quizAnalytics.nome = userVariables.nome || "";
  quizAnalytics.email = userVariables.email || "";
  quizAnalytics.whatsapp = userVariables.whatsapp || "";
  quizAnalytics.city = quizAnalytics.city || "Desconhecida"; // Garantir que a cidade esteja definida

  const dataToSend = [quizAnalytics];
  const blob = new Blob(
    [new URLSearchParams({ data: JSON.stringify(dataToSend) })],
    { type: "application/x-www-form-urlencoded" }
  );

  // Enviar dados usando sendBeacon
  const beaconSent = navigator.sendBeacon(
    ANALYTICS_CONFIG.webhookUrl,
    blob
  );

  if (beaconSent) {
    // Se sendBeacon retornou true, podemos redirecionar imediatamente
    window.location.href = url;
  } else {
    // Se sendBeacon falhou, enviar via fetch com atraso
    fetch(ANALYTICS_CONFIG.webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        data: JSON.stringify(dataToSend),
      }),
    })
      .then(() => {
        window.location.href = url;
      })
      .catch((error) => {
        console.error("Erro ao enviar analytics:", error);
        // Mesmo em caso de erro, redirecionar
        window.location.href = url;
      });
  }

  // Opcional: Alternativamente, adicionar um atraso para garantir o envio
  /*
  sendAnalytics().then(() => {
    window.location.href = url;
  }).catch((error) => {
    console.error("Erro ao enviar analytics:", error);
    window.location.href = url;
  });
  */
}




     /*************************************************************
     * 6) FUNÇÃO PARA BUSCAR A CIDADE, ESTADO E CÓDIGO POSTAL DO USUÁRIO COM IPAPI.CO
     *************************************************************/
    let locationFetched = false; // Flag para evitar múltiplas chamadas

    async function fetchUserLocation() {
      if (locationFetched) return; // Evita múltiplas chamadas
      locationFetched = true; // Marca que a localização já foi buscada

      console.log("Iniciando fetchUserLocation...");

      try {
        const response = await fetch("https://ipapi.co/json/");
        if (!response.ok) throw new Error("ipapi.co falhou");
        const data = await response.json();
        if (!data) throw new Error("Nenhum dado recebido da ipapi.co");

        // Atualizar cidade
        quizAnalytics.city = data.city || "Desconhecida";

        // Atualizar estado (abreviação)
        quizAnalytics.state = data.region || "Desconhecido";

        // Atualizar código postal
        quizAnalytics.postalCode = data.postal || "Desconhecido";

        console.log("Localização do usuário:", quizAnalytics.city, quizAnalytics.state, quizAnalytics.postalCode);
      } catch (error) {
        console.error("Erro ao buscar a localização via ipapi.co:", error);
        // Caso a ipapi.co falhe, defina os campos como "Desconhecido"
        quizAnalytics.city = "Desconhecida";
        quizAnalytics.state = "Desconhecido";
        quizAnalytics.postalCode = "Desconhecido";
      }
    }

       /*************************************************************
       * 7) FUNÇÃO PARA CONFIGURAR BOTÕES COM DELAY
       *************************************************************/
function setupDelayedButtons(section) {
  const buttons = section.querySelectorAll(".mobile-button[data-delay]");
  buttons.forEach((button) => {
    // Inicialmente, esconder o botão e desabilitar interações
    button.style.opacity = "0";
    button.style.pointerEvents = "none"; // Desabilitar cliques e interações

    const delayAttr = button.getAttribute("data-delay");
    const delaySeconds = parseFloat(delayAttr);
    const delay = isNaN(delaySeconds) ? 0 : delaySeconds * 1000; // Converter para milissegundos

    setTimeout(() => {
      // Tornar o botão visível
      button.style.opacity = "1";

      // Habilitar interações imediatamente após definir a opacidade
      button.style.pointerEvents = "auto";
    }, delay);
  });
}

/*************************************************************
 * 8) FUNÇÃO PRINCIPAL PARA MOSTRAR UMA SEÇÃO
 *************************************************************/
function showSection(sectionId) {
   pauseAllVideos(); 

  console.log("Showing section:", sectionId);

  // Remover 'active' de todas as seções e parar autoplay de galerias
  const sections = document.querySelectorAll(".quiz-section");
  sections.forEach((section) => {
    section.classList.remove("active");
    section.querySelectorAll(".mobile-gallery").forEach((gallery) => {
      if (gallery.galleryInstance) {
        gallery.galleryInstance.stopAutoplay();
      }
    });
    // Ocultar botões e buscar cidade
    const buttons = section.querySelectorAll(".mobile-button");
    buttons.forEach((button) => {
      button.style.opacity = "0";
      button.style.transition = "none";
      button.style.pointerEvents = "none"; // Garantir que estejam desabilitados
    });
  });

  // Encontrar e ativar a seção alvo
  const targetSection = document.getElementById(sectionId);
  if (targetSection) {
    targetSection.classList.add("active"); // Tornar a seção ativa

    // Forçar a rolagem para o topo
    window.scrollTo({ top: 0, behavior: "auto" });
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;

    // Exibir botões com delay
    setupDelayedButtons(targetSection);

    // Exibir botões sem delay imediatamente
    const regularButtons = targetSection.querySelectorAll(".mobile-button:not([data-delay])");
    regularButtons.forEach((button) => {
      button.style.opacity = "1";
      button.style.transition = "opacity 0.3s ease";
      button.style.pointerEvents = "auto"; // Habilitar cliques e interações
    });

    // Chamadas extras: barras de progresso, inputs, etc.
    animateProgressBars(targetSection);
    animateScores(targetSection); // <-- insira aqui
    interpolateVariables(targetSection);
    setupInputWidget(targetSection.querySelector(".input-widget"));
    initializeGalleries(targetSection); // Inicializar galerias na seção
    // Buscar a cidade do usuário
    fetchUserLocation();

    // Atualizar furthestSection se necessário
    const indexNow = parseInt(sectionId.split("-")[1]) || 0;
    const indexFurthest = parseInt(quizAnalytics.furthestSection.split("-")[1]) || 0;
    if (indexNow > indexFurthest) {
      quizAnalytics.furthestSection = sectionId;
    }
  }
}


    /*************************************************************
 * 9) FUNÇÃO PARA TRATAR CONCLUSÃO DE PROGRESSO
 *************************************************************/
function handleProgressCompletion(progressElement) {
  const enableRedirect =
    progressElement.getAttribute("data-enable-redirect") === "true";
  if (enableRedirect) {
    setTimeout(function () {
      const redirectLink =
        progressElement.getAttribute("data-redirect-link");
      if (redirectLink) {
        // Verifica se os dados já foram enviados
        if (!dataSent) {
          quizAnalytics.endTime = Date.now(); // Registrar o tempo de término
          sendAnalyticsAndRedirect(redirectLink);
        } else {
          // Se os dados já foram enviados, apenas redireciona
          window.location.href = redirectLink;
        }
      } else {
        const connection = connectionsData.find(function (conn) {
          return conn.elementId === progressElement.id;
        });
        if (connection) {
          showSection("section-" + connection.endIndex);
        }
      }
    }, 1000);
  }
}


/*************************************************************
 * 10) FUNÇÃO PARA ANIMAR BARRAS DE PROGRESSO
 *************************************************************/
function animateProgressBars(section) {
  const progressBars = section.querySelectorAll(".mobile-progress");
  progressBars.forEach(function (progress) {
    const progressBar = progress.querySelector(".progress-fill");
    const progressValue = progress.querySelector(".progress-value");
    const start = parseInt(progress.getAttribute("data-start")) || 0;
    const end = parseInt(progress.getAttribute("data-end")) || 100;
    const enableRedirect =
      progress.getAttribute("data-enable-redirect") === "true";
    const duration =
      parseInt(progress.getAttribute("data-duration")) || 1;
    console.log(
      "Animating progress bar:",
      progress.id,
      "from",
      start,
      "to",
      end,
      "duration:",
      duration
    );
    progressBar.style.width = start + "%";
    progressValue.textContent = start + "%";
    let current = start;
    const increment = (end - start) / (duration * 50); // 50 fps
    const interval = setInterval(function () {
      current += increment;
      if (current >= end) {
        current = end;
        clearInterval(interval);
        console.log("Progress bar reached 100%");
        if (enableRedirect) {
          handleProgressCompletion(progress);
        }
      }
      progressBar.style.width = current + "%";
      progressValue.textContent = Math.round(current) + "%";
    }, 20);
  });
}


            
/*************************************************************
 * 11) EVENTO DOMContentLoaded PARA INICIALIZAR PRIMEIRA SEÇÃO
 *************************************************************/
document.addEventListener("DOMContentLoaded", function () {
  console.log("DOM fully loaded");
  const firstSection = document.querySelector(".quiz-section");
  if (firstSection && firstSection.id) {
    console.log("Activating first section using showSection");
    showSection(firstSection.id); // Chama a função showSection para configurar a seção corretamente
    dataSent = false; // Resetar a flag para permitir novos envios
  } else {
    console.error("Primeira seção não encontrada ou não possui um ID.");
  }
});


      /*************************************************************
       * 14) CONFIGURAÇÃO DE CORES DE HOVER PARA BOTÕES MOBILE
       *************************************************************/
      document.querySelectorAll(".mobile-button").forEach(function (button) {
        const hoverColor = button.getAttribute("data-hover-color");
        if (hoverColor) {
          button.style.setProperty("--hover-color", hoverColor); // Definir cor de hover via CSS variável
        }
      });


      /*************************************************************
       * 16) EVENTO DOMContentLoaded PARA CONFIGURAR MULTIPLE CHOICE E OBSERVER
       *************************************************************/
      document.addEventListener("DOMContentLoaded", function () {
        /**
         * Reseta múltiplas escolhas clonando botões para remover event listeners anteriores
         * @param {HTMLElement} widget - O widget de múltipla escolha
         * @returns {Object} - Contém opções clonadas, botão de continuar e cores
         */
        function resetMultipleChoice(widget) {
          const options = widget.querySelectorAll(".option-button");
          const continueButton = widget.querySelector(".continue-button");
          const continueColor = continueButton.style.backgroundColor;
          const checkboxColor =
            options[0]?.querySelector(".checkbox")?.style.borderColor ||
            "#d6d6d6";

          // Clonar opções para remover event listeners
          options.forEach((option) => {
            const clone = option.cloneNode(true);
            option.parentNode.replaceChild(clone, option);
          });

          // Clonar botão de continuar
          const clonedButton = continueButton.cloneNode(true);
          continueButton.parentNode.replaceChild(clonedButton, continueButton);

          // Resetar estilos das opções
          widget.querySelectorAll(".option-button").forEach((option) => {
            option.classList.remove("active");
            const checkbox = option.querySelector(".checkbox");
            if (checkbox) {
              checkbox.style.backgroundColor = "";
              checkbox.style.borderColor = checkboxColor;
            }
          });

          // Resetar estilo do botão de continuar
          clonedButton.classList.remove("active");
          clonedButton.style.opacity = "0.5";
          clonedButton.style.cursor = "not-allowed";

          return {
            options: widget.querySelectorAll(".option-button"),
            continueButton: clonedButton,
            continueColor,
            checkboxColor,
          };
        }

        /**
         * Configura múltiplas escolhas adicionando event listeners
         */
        const setupMultipleChoice = () => {
          document
            .querySelectorAll(".mobile-multiple-choice")
            .forEach((widget) => {
              const { options, continueButton, continueColor, checkboxColor } =
                resetMultipleChoice(widget);

              /**
               * Atualiza o botão de continuar com base na seleção
               * @param {HTMLElement} widget - O widget de múltipla escolha
               * @param {HTMLElement} continueButton - O botão de continuar
               * @returns {number} - Número de opções selecionadas
               */
              function updateContinueButton(widget, continueButton) {
                const selectedCount = widget.querySelectorAll(
                  ".option-button.active"
                ).length;
                const isActive = selectedCount > 0;

                continueButton.classList.toggle("active", isActive);
                continueButton.style.opacity = isActive ? "1" : "0.5";
                continueButton.style.cursor = isActive
                  ? "pointer"
                  : "not-allowed";
                return selectedCount;
              }

              /**
               * Manipulador de clique nas opções
               * @param {Event} e - Evento de clique
               */
              function handleOptionClick(e) {
                e.preventDefault();
                this.classList.toggle("active"); // Toggle active class
                const checkbox = this.querySelector(".checkbox");

                if (this.classList.contains("active")) {
                  checkbox.style.backgroundColor = checkboxColor;
                  checkbox.style.borderColor = checkboxColor;
                } else {
                  checkbox.style.backgroundColor = "";
                  checkbox.style.borderColor = checkboxColor;
                }

                updateContinueButton(widget, continueButton); // Atualizar botão de continuar
              }

              // Adicionar event listeners às opções
              options.forEach((option) => {
                option.addEventListener("click", handleOptionClick);
              });

              // Adicionar event listener ao botão de continuar
              continueButton.addEventListener("click", () => {
                const selectedCount = widget.querySelectorAll(
                  ".option-button.active"
                ).length;
                if (selectedCount > 0) {
                  const connection = connectionsData.find(
                    (conn) => conn.elementId === widget.id
                  );
                  if (connection) {
                    showSection("section-" + connection.endIndex); // Navegar para a próxima seção
                  }
                }
              });
            });
        };

        setupMultipleChoice(); // Inicializar múltiplas escolhas

        /**
         * Observador de mutações para detectar mudanças de seção
         */
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.target.classList.contains("active")) {
              setupMultipleChoice(); // Reconfigurar múltiplas escolhas na nova seção
              setupInputWidget(mutation.target.querySelector(".input-widget")); // Configurar widgets de input
            }
          });
        });

        // Observar todas as seções do quiz
        document.querySelectorAll(".quiz-section").forEach((section) => {
          observer.observe(section, {
            attributes: true,
            attributeFilter: ["class"],
          });
        });
      });

      /*************************************************************
       * 17) SISTEMA DE VARIÁVEIS USUÁRIO
       *************************************************************/
      let userVariables = JSON.parse(
        sessionStorage.getItem("userVariables") || "{}"
      ); // Recuperar variáveis do usuário

      /**
       * Configura um widget de input para armazenar variáveis do usuário
       * @param {HTMLElement} widget - O widget de input
       */
      function setupInputWidget(widget) {
        if (!widget) return;

        const input = widget.querySelector(".input-field");
        const button = widget.querySelector(".continue-button");
        const variable = input.getAttribute("data-variable");

        button.disabled = true;
        button.style.opacity = "0.5";
        button.style.cursor = "not-allowed";

        // Preencher input se já existir valor
        if (userVariables[variable]) {
          input.value = userVariables[variable];
          button.disabled = false;
          button.style.opacity = "1";
          button.style.cursor = "pointer";
        }

        // Evento de input para atualizar variáveis e estado do botão
        input.addEventListener("input", function () {
          const hasValue = this.value.trim().length > 0;
          button.disabled = !hasValue;
          button.style.opacity = hasValue ? "1" : "0.5";
          button.style.cursor = hasValue ? "pointer" : "not-allowed";

          userVariables[variable] = this.value;
          sessionStorage.setItem(
            "userVariables",
            JSON.stringify(userVariables)
          ); // Salvar no sessionStorage
        });

        // Evento de clique no botão de continuar
        button.addEventListener("click", function () {
          if (input.value.trim().length > 0) {
            const connection = connectionsData.find(
              (conn) => conn.elementId === widget.id
            );
            if (connection) {
              showSection("section-" + connection.endIndex); // Navegar para a próxima seção
            }
          }
        });
      }

      /**
       * Interpola variáveis nos textos das seções
       * @param {HTMLElement} section - A seção onde interpolar
       */
      function interpolateVariables(section) {
        const textNodes = Array.from(section.getElementsByTagName("*"))
          .filter((el) => !el.children.length && el.textContent.includes("{{"))
          .map((el) => ({ element: el, original: el.textContent }));

        textNodes.forEach(({ element, original }) => {
          let text = original;
          const matches = text.match(/{{([^}]+)}}/g) || [];

          matches.forEach((match) => {
            const variable = match.slice(2, -2).trim();
            const value =
              userVariables[variable] || quizAnalytics[variable] || "";
            text = text.replace(match, value);
          });

          element.textContent = text; // Atualizar o texto com as variáveis interpoladas
        });
      }

      /*************************************************************
       * 18) FUNÇÃO PARA INICIALIZAR TODAS AS GALERIAS
       *************************************************************/
      function initializeGalleries(container = document) {
        container.querySelectorAll(".mobile-gallery").forEach((gallery) => {
          const existingGallery = gallery.galleryInstance;
          if (existingGallery) {
            existingGallery.stopAutoplay(); // Parar autoplay se já existir
          }
          gallery.galleryInstance = new Gallery(gallery); // Inicializar nova galeria
        });
      }

      /*************************************************************
       * 19) CLASSE PARA GERENCIAR GALERIAS DE IMAGENS
       *************************************************************/
      class Gallery {
        constructor(element) {
          this.gallery = element;
          this.track = element.querySelector(".gallery-track");
          this.slides = [...element.querySelectorAll(".gallery-slide")];
          this.dots = [...element.querySelectorAll(".gallery-dot")];
          this.currentSlide = 0;
          this.autoplayInterval = null;

          // Obter cores definidas nos dots ou usar padrão
          const dots = element.querySelectorAll(".gallery-dot");
          const firstDot = dots[0];
          const secondDot = dots[1];

          this.dotActiveColor = firstDot?.style.backgroundColor || "#9333ea";
          this.dotColor = secondDot?.style.backgroundColor || "#ccc";

          // Configurar estilos dos dots
          this.dots.forEach((dot, index) => {
            dot.style.transition = "all 0.3s ease";
            this.updateDotStyle(dot, index === 0);
          });

          // Adicionar event listeners aos dots
          this.dots.forEach((dot, index) => {
            dot.addEventListener("click", () => this.goToSlide(index));
          });

          // Eventos de toque para dispositivos móveis
          this.touchStartX = 0;
          this.touchEndX = 0;

          this.track.addEventListener("touchstart", (e) => this.touchStart(e));
          this.track.addEventListener("touchmove", (e) => this.touchMove(e));
          this.track.addEventListener("touchend", (e) => this.touchEnd(e));

          // Eventos para pausar e retomar autoplay
          this.track.addEventListener("mouseenter", () => this.stopAutoplay());
          this.track.addEventListener("mouseleave", () => this.startAutoplay());

          // Atualizar cores dos dots e iniciar autoplay
          this.updateDotColors();
          this.startAutoplay();
        }

        /**
         * Atualiza o estilo de um dot com base no estado ativo
         * @param {HTMLElement} dot - O dot a ser atualizado
         * @param {boolean} isActive - Se o dot está ativo
         */
        updateDotStyle(dot, isActive) {
          dot.style.backgroundColor = isActive
            ? this.dotActiveColor
            : this.dotColor;
          dot.style.transform = isActive ? "scale(1.2)" : "scale(1)";
        }

        /**
         * Atualiza as cores de todos os dots com base no slide atual
         */
        updateDotColors() {
          this.dots.forEach((dot, index) => {
            this.updateDotStyle(dot, index === this.currentSlide);
          });
        }

        /**
         * Inicia o autoplay da galeria
         */
        startAutoplay() {
          this.stopAutoplay(); // Garantir que não haja múltiplos intervalos
          this.autoplayInterval = setInterval(() => this.next(), 3000); // Avançar a cada 3 segundos
        }

        /**
         * Para o autoplay da galeria
         */
        stopAutoplay() {
          if (this.autoplayInterval) {
            clearInterval(this.autoplayInterval);
            this.autoplayInterval = null;
          }
        }

        /**
         * Atualiza a posição do slide atual
         */
        updateSlide() {
          this.track.style.transition = "transform 0.3s ease";
          this.track.style.transform = `translateX(-${
            this.currentSlide * 100
          }%)`;
          this.updateDotColors(); // Atualizar cores dos dots
        }

        /**
         * Avança para o próximo slide
         */
        next() {
          this.currentSlide = (this.currentSlide + 1) % this.slides.length;
          this.updateSlide();
        }

        /**
         * Retrocede para o slide anterior
         */
        prev() {
          this.currentSlide =
            (this.currentSlide - 1 + this.slides.length) % this.slides.length;
          this.updateSlide();
        }

        /**
         * Vai para um slide específico
         * @param {number} index - Índice do slide
         */
        goToSlide(index) {
          this.currentSlide = index;
          this.updateSlide();
          this.stopAutoplay(); // Parar autoplay temporariamente
          this.startAutoplay(); // Reiniciar autoplay
        }

        /**
         * Evento de início de toque
         * @param {Event} e - Evento de toque
         */
        touchStart(e) {
          this.touchStartX = e.touches[0].clientX;
          this.stopAutoplay(); // Parar autoplay durante o toque
          this.track.style.transition = "none";
        }

        /**
         * Evento de movimento de toque
         * @param {Event} e - Evento de toque
         */
        touchMove(e) {
          if (!this.touchStartX) return;
          e.preventDefault();
          const currentX = e.touches[0].clientX;
          const diff = this.touchStartX - currentX;
          const moveX = -(diff + this.currentSlide * this.gallery.offsetWidth);
          this.track.style.transform = `translateX(${moveX}px)`;
        }

        /**
         * Evento de fim de toque
         * @param {Event} e - Evento de toque
         */
        touchEnd(e) {
          const touchEndX = e.changedTouches[0].clientX;
          const diff = this.touchStartX - touchEndX;

          if (Math.abs(diff) > 50) {
            // Se o swipe for significativo
            if (diff > 0) this.next();
            else this.prev();
          } else {
            this.updateSlide(); // Reposicionar se o swipe não for significativo
          }

          this.touchStartX = 0;
          this.startAutoplay(); // Reiniciar autoplay
        }
      }

      /*************************************************************
       * 20) FUNÇÃO PARA INICIALIZAR VIDEOS DO YOUTUBE
       *************************************************************/
      // Objeto para armazenar todos os players
      const videoPlayers = new Map();

      /**
       * Inicializa um player de vídeo do YouTube
       * @param {HTMLElement} videoDiv - O div que contém o vídeo
       */
      function initializeVideo(videoDiv) {
        const uniqueId = videoDiv.id.split("-")[1];
        const startOverlay = videoDiv.querySelector(
          `#start-overlay-${uniqueId}`
        );
        const pauseOverlay = videoDiv.querySelector(
          `#pause-overlay-${uniqueId}`
        );
        const blurBg = videoDiv.querySelector(`#blur-bg-${uniqueId}`);
        const iframe = videoDiv.querySelector(`#youtube-video-${uniqueId}`);

        if (!iframe) return; // Se não houver iframe, sair

        const player = new YT.Player(`youtube-video-${uniqueId}`, {
          events: {
            onReady: function () {
              startOverlay.style.display = "flex"; // Mostrar overlay de início
              blurBg.style.display = "block"; // Mostrar fundo borrado

              // Definir a qualidade do vídeo para HD (1080p)
              player.setPlaybackQuality("hd1080");

              // Evento de clique no overlay de início para reproduzir vídeo
              startOverlay.onclick = () => {
                player.playVideo();
                startOverlay.style.display = "none";
                blurBg.style.display = "none";
              };

              // Evento de clique no overlay de pausa para retomar vídeo
              pauseOverlay.onclick = () => {
                player.playVideo();
                pauseOverlay.style.display = "none";
                blurBg.style.display = "none";
              };
            },
            onStateChange: function (event) {
              if (event.data === YT.PlayerState.PAUSED) {
                pauseOverlay.style.display = "flex"; // Mostrar overlay de pausa
                blurBg.style.display = "block";
              } else if (event.data === YT.PlayerState.ENDED) {
                startOverlay.style.display = "flex"; // Mostrar overlay de fim
                pauseOverlay.style.display = "none";
                blurBg.style.display = "block";
              } else if (event.data === YT.PlayerState.PLAYING) {
                startOverlay.style.display = "none"; // Esconder overlays quando reproduzindo
                pauseOverlay.style.display = "none";
                blurBg.style.display = "none";

                // Assegurar que a qualidade esteja em HD
                player.setPlaybackQuality("hd1080");
              }
            },
          },
        });

        // Armazena o player para uso posterior
        videoPlayers.set(uniqueId, player);
      }

      /**
       * Função callback chamada quando a API do YouTube está pronta
       */
      function onYouTubeIframeAPIReady() {
        // Inicializa todos os vídeos presentes na página
        document.querySelectorAll(".mobile-video").forEach((videoDiv) => {
          initializeVideo(videoDiv);
        });
      }

      /**
       * Observador de mutações para detectar quando uma seção se torna ativa e inicializar vídeos
       */
      const videoObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.target.classList.contains("active")) {
            mutation.target
              .querySelectorAll(".mobile-video")
              .forEach((videoDiv) => {
                if (!videoPlayers.has(videoDiv.id.split("-")[1])) {
                  initializeVideo(videoDiv); // Inicializar vídeo se ainda não estiver inicializado
                }
              });
          }
        });
      });

      // Observar todas as seções do quiz para inicializar vídeos quando se tornam ativas
      document.querySelectorAll(".quiz-section").forEach((section) => {
        videoObserver.observe(section, {
          attributes: true,
          attributeFilter: ["class"],
          subtree: true,
        });
      });

      /*************************************************************
       * 21) FUNÇÃO PARA pausar video quando troca de cessao
       *************************************************************/
      function pauseAllVideos() {
        videoPlayers.forEach(player => {
          player.pauseVideo();
        });
      }

      /*************************************************************
       * 22) // Inicializa os FAQs
       *************************************************************/
     
    document.querySelectorAll(".faq-header").forEach((header) => {
      header.addEventListener("click", () => {
        // Toggle active class no header
        header.classList.toggle("active");
        
        // Toggle o content
        const content = header.nextElementSibling;
        content.classList.toggle("active");
        
        // Ajusta altura do conteúdo
        if (content.classList.contains("active")) {
          content.style.maxHeight = content.scrollHeight + "px";
        } else {
          content.style.maxHeight = "0";
        }
      });
    });
  

      /*************************************************************
       * 23) anima score
       *************************************************************/
      /**
   * Função para animar cada Score de uma Seção
   * @param {HTMLElement} section - Seção do quiz que está sendo exibida
   */
  function animateScores(section) {
    const scoreElements = section.querySelectorAll('.mobile-score');
    scoreElements.forEach((scoreEl) => {
      const circleWrap = scoreEl.querySelector('.circle-wrap');
      const percentEl = scoreEl.querySelector('.percent');
      const targetValue = parseInt(percentEl.textContent, 10) || 0;
      const primaryColor = scoreEl.getAttribute('data-primary-color') || "#a31b1b";
      const secondaryColor = scoreEl.getAttribute('data-secondary-color') || "#dc2626";
      const bgColor = scoreEl.getAttribute('data-bg-color') || "#f8f9fe";
      animateScore(circleWrap, percentEl, targetValue, primaryColor, secondaryColor, bgColor);
    });
  }
 /**
   * Função genérica de animação do Score
   * @param {HTMLElement} circleWrap - Div que recebe o 'background' com conic-gradient
   * @param {HTMLElement} percentEl - Elemento que mostra o valor atual (em %)
   * @param {number} targetValue - Valor final da pontuação (ex: 85)
   * @param {string} primaryColor - Cor inicial do gradiente
   * @param {string} secondaryColor - Cor final do gradiente
   * @param {string} bgColor - Cor de fundo do centro (onde fica o número)
   */
  function animateScore(circleWrap, percentEl, targetValue, primaryColor, secondaryColor, bgColor) {
    let currentValue = 0;
    // Intervalo ~50 FPS
    const stepTimeMs = 20;

    // Inicia em 0%
    percentEl.textContent = "0%";
    // Reseta o conic-gradient, começando tudo em 0%
    circleWrap.style.background = `conic-gradient(${primaryColor} 0%, ${secondaryColor} 0%, rgb(229, 231, 235) 0%)`;

    const intervalId = setInterval(() => {
      if (currentValue >= targetValue) {
        clearInterval(intervalId);
        return;
      }
      currentValue++;

      // Atualiza o conic-gradient
      circleWrap.style.background = `
        conic-gradient(
          ${primaryColor} 0%,
          ${secondaryColor} ${currentValue}%,
          rgb(229, 231, 235) ${currentValue}%
        )
      `;
      // Atualiza texto
      percentEl.textContent = currentValue + "%";
      // Mantém a cor do círculo central
      percentEl.style.backgroundColor = bgColor;
    }, stepTimeMs);
  }
      /*************************************************************
       * 24) FINALIZAÇÃO DA INICIALIZAÇÃO DE GALERIAS E EVENTOS DOMContentLoaded
       *************************************************************/
      // Já tratado anteriormente no evento DOMContentLoaded

      /*************************************************************
       * 25) INICIALIZAÇÃO DE TODOS OS WIDGETS DE INPUT
       *************************************************************/
      document.querySelectorAll(".input-widget").forEach(setupInputWidget);
    </script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
      /*************************************************************
       * 26) CLASSE PARA GERENCIAR GALERIAS DE IMAGENS
       *************************************************************/
      // Já definida anteriormente como Gallery

      /*************************************************************
       * 27) FUNÇÃO PARA INICIALIZAR GALERIAS EM UM CONTÊINER ESPECÍFICO
       *************************************************************/
      // Já definida anteriormente como initializeGalleries

      /*************************************************************
       * 28) FUNÇÃO PARA ATUALIZAR A FUNÇÃO showSection COM INICIALIZAÇÃO DE GALERIAS
       *************************************************************/
      // Já definida anteriormente, não é necessário duplicar

      /*************************************************************
       * 29) FINALIZAÇÃO DA INICIALIZAÇÃO DE GALERIAS E EVENTOS DOMContentLoaded
       *************************************************************/
      // Já tratado anteriormente no evento DOMContentLoaded
      
    </script>
  </body>
</html>
